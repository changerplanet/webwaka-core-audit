WebWaka Modular Rebuild ‚Äî Phase 2 / Step 04

Core Audit Service Implementation

Repository: changerplanet/webwaka-core-audit
Implementation Platform: Replit (TypeScript-only project)
Account: Replit-XX (dedicated to this repo)

‚∏ª

CONTEXT (AUTHORITATIVE ‚Äî READ FIRST)

You are implementing Phase 2 ‚Äî Step 04 of the WebWaka Modular Rebuild.

This step implements the canonical Core Audit module for WebWaka.

All governance, CI/CD, repo setup, and Vercel binding are already complete.

You must clone the existing GitHub repository first, then implement strictly within it.

‚∏ª

1. REPOSITORY & GIT RULES (MANDATORY)

Repository
	‚Ä¢	GitHub Repo: https://github.com/changerplanet/webwaka-core-audit
	‚Ä¢	Repo is public
	‚Ä¢	You MUST:
	1.	Clone the repo first
	2.	Work directly on main
	3.	Push commits directly to main (branching not required here)

Governance Constraints

Do NOT delete or rename:
	‚Ä¢	README.md
	‚Ä¢	module.manifest.json
	‚Ä¢	module.contract.md
	‚Ä¢	CHANGELOG.md
	‚Ä¢	OWNERS.md
	‚Ä¢	SECURITY.md
	‚Ä¢	.github/workflows/ci.yml

You MAY update:
	‚Ä¢	module.manifest.json
	‚Ä¢	module.contract.md
	‚Ä¢	CHANGELOG.md

‚∏ª

2. TECH STACK (NON-NEGOTIABLE)
	‚Ä¢	Language: TypeScript only
	‚Ä¢	Project Type: Headless library (NO UI)
	‚Ä¢	Frameworks: ‚ùå None (no React, no FastAPI)
	‚Ä¢	Validation: Zod
	‚Ä¢	Crypto: Node.js crypto (SHA-256)
	‚Ä¢	Tests: Jest
	‚Ä¢	Storage: Abstract interface only (no DB assumptions)

‚∏ª

3. MODULE PURPOSE

Implement a tenant-isolated, append-only, tamper-evident audit log system that:
	‚Ä¢	Records who did what, when, under which tenant
	‚Ä¢	Cannot be mutated silently
	‚Ä¢	Can prove integrity
	‚Ä¢	Can detect tampering
	‚Ä¢	Is usable by:
	‚Ä¢	POS
	‚Ä¢	Payments
	‚Ä¢	Receipts
	‚Ä¢	Marketplace
	‚Ä¢	Compliance modules later

‚∏ª

4. FUNCTIONAL REQUIREMENTS

4.1 Core Service

Implement an AuditService class exposing at minimum:

logEvent(input): Promise<AuditEvent>
getEvent(tenantId, eventId): Promise<AuditEvent | null>
queryEvents(input): Promise<AuditEventQueryResult>
verifyIntegrity(tenantId): Promise<TamperDetectionResult>
proveEvent(tenantId, eventId): Promise<AuditProof | null>

4.2 Audit Event Model

Each event MUST include:
	‚Ä¢	eventId
	‚Ä¢	tenantId
	‚Ä¢	actor (user | system | service)
	‚Ä¢	action
	‚Ä¢	metadata
	‚Ä¢	timestamp
	‚Ä¢	hash
	‚Ä¢	previousHash | null

4.3 Cryptographic Integrity
	‚Ä¢	Use SHA-256
	‚Ä¢	Hash formula MUST include:

hash = SHA256(eventPayload + previousHash)


	‚Ä¢	Hash chain must be tenant-scoped

‚∏ª

5. STORAGE ABSTRACTION (CRITICAL)

Define an interface:

interface AuditStorage {
  append(event)
  getById(tenantId, eventId)
  query(tenantId, filters)
  getLastHash(tenantId)
}

Provide:
	‚Ä¢	InMemoryAuditStorage (for tests only)

‚∏ª

6. TENANT ISOLATION RULES
	‚Ä¢	Every method must require tenantId
	‚Ä¢	No cross-tenant queries allowed
	‚Ä¢	Integrity checks are tenant-scoped

‚∏ª

7. OSS COMPLIANCE

This implementation follows a hash-chained append-only audit log pattern, which is:
	‚Ä¢	Industry-proven
	‚Ä¢	Auditor-approved
	‚Ä¢	OSS-safe
	‚Ä¢	Infrastructure-free

DO NOT introduce:
	‚Ä¢	Databases
	‚Ä¢	Message queues
	‚Ä¢	External logging systems
	‚Ä¢	Blockchain
	‚Ä¢	SaaS dependencies

‚∏ª

8. TESTING REQUIREMENTS (MANDATORY)

You must implement comprehensive tests proving:
	1.	Events append correctly
	2.	Hash chaining is correct
	3.	Tampering is detected
	4.	Tenant isolation is enforced
	5.	proveEvent() returns verifiable proof
	6.	verifyIntegrity() fails if any event is mutated

Target:
	‚Ä¢	‚â• 80% coverage
	‚Ä¢	Tests must explicitly prove the hard stop condition

‚∏ª

9. HARD STOP CONDITION (MUST BE PROVEN BY TEST)

Any module can emit an audit event and later prove who did what, when, under which tenant context, and detect if the audit trail was tampered with.

Include a test named similar to:

"module can emit audit event and later cryptographically prove integrity"

‚∏ª

10. DOCUMENTATION UPDATES

Update:
	‚Ä¢	module.contract.md ‚Üí Public APIs & guarantees
	‚Ä¢	CHANGELOG.md ‚Üí Phase 2 / Step 04 entry
	‚Ä¢	module.manifest.json ‚Üí
	‚Ä¢	Declare capabilities (e.g. audit:log, audit:verify)
	‚Ä¢	Declare dependency on webwaka-core-identity

‚∏ª

11. CI EXPECTATIONS
	‚Ä¢	All tests must pass
	‚Ä¢	CI must remain green
	‚Ä¢	No skipped tests
	‚Ä¢	No TODO placeholders

‚∏ª

12. DELIVERY FORMAT

When done, respond with:
	1.	Completion Summary
	2.	Public APIs
	3.	Hard Stop Proof
	4.	Test Coverage Stats
	5.	Final Commit SHA
	6.	Explicit STOP statement

Example ending:

STOP ‚Äî Awaiting authorization for Phase 2 ‚Äî Step 05 (Receipts)

‚∏ª

üö´ DO NOT PROCEED BEYOND STEP 04

Until explicit authorization is given.